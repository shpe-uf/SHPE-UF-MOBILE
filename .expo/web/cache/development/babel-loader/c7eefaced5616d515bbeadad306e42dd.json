{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nexport default function getActionFromState(state, options) {\n  var normalizedConfig = options ? createNormalizedConfigItem(options) : {};\n  var payload;\n  var current = state;\n  var config = normalizedConfig;\n  var params = {};\n\n  while (current) {\n    var _config, _config2, _config2$screens;\n\n    if (current.routes.length === 0) {\n      return undefined;\n    }\n\n    var route = current.routes[current.routes.length - 1];\n\n    if (current.routes.length === 1) {\n      params.initial = true;\n      params.screen = route.name;\n      params.state = undefined;\n    } else if (current.routes.length === 2 && current.routes[0].key === undefined && current.routes[0].name === ((_config = config) === null || _config === void 0 ? void 0 : _config.initialRouteName)) {\n      params.initial = false;\n      params.screen = route.name;\n      params.state = undefined;\n    } else {\n      params.initial = undefined;\n      params.screen = undefined;\n      params.params = undefined;\n      params.state = current;\n      break;\n    }\n\n    if (route.state) {\n      params.params = _objectSpread({}, route.params);\n      params = params.params;\n    } else {\n      params.params = route.params;\n    }\n\n    current = route.state;\n    config = (_config2 = config) === null || _config2 === void 0 ? void 0 : (_config2$screens = _config2.screens) === null || _config2$screens === void 0 ? void 0 : _config2$screens[route.name];\n\n    if (!payload) {\n      payload = {\n        name: route.name,\n        params: params\n      };\n    }\n  }\n\n  if (!payload) {\n    return;\n  }\n\n  return {\n    type: 'NAVIGATE',\n    payload: payload\n  };\n}\n\nvar createNormalizedConfigItem = function createNormalizedConfigItem(config) {\n  return typeof config === 'object' && config != null ? {\n    initialRouteName: config.initialRouteName,\n    screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined\n  } : {};\n};\n\nvar createNormalizedConfigs = function createNormalizedConfigs(options) {\n  return Object.entries(options).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        k = _ref2[0],\n        v = _ref2[1];\n\n    acc[k] = createNormalizedConfigItem(v);\n    return acc;\n  }, {});\n};","map":{"version":3,"sources":["getActionFromState.tsx"],"names":["normalizedConfig","options","createNormalizedConfigItem","current","config","params","route","payload","name","type","initialRouteName","screens","createNormalizedConfigs","undefined","acc"],"mappings":"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","sourcesContent":["import type {\n  Route,\n  PartialRoute,\n  NavigationState,\n  PartialState,\n} from '@react-navigation/routers';\nimport type { PathConfig, PathConfigMap, NestedNavigateParams } from './types';\n\ntype ConfigItem = {\n  initialRouteName?: string;\n  screens?: Record<string, ConfigItem>;\n};\n\ntype Options = { initialRouteName?: string; screens: PathConfigMap };\n\ntype NavigateAction<State extends NavigationState> = {\n  type: 'NAVIGATE';\n  payload: {\n    name: string;\n    params?: NestedNavigateParams<State>;\n  };\n};\n\nexport default function getActionFromState(\n  state: PartialState<NavigationState>,\n  options?: Options\n): NavigateAction<NavigationState> | undefined {\n  // Create a normalized configs object which will be easier to use\n  const normalizedConfig = options ? createNormalizedConfigItem(options) : {};\n\n  let payload;\n  let current: PartialState<NavigationState> | undefined = state;\n  let config: ConfigItem | undefined = normalizedConfig;\n  let params: NestedNavigateParams<NavigationState> = {};\n\n  while (current) {\n    if (current.routes.length === 0) {\n      return undefined;\n    }\n\n    const route: Route<string> | PartialRoute<Route<string>> =\n      current.routes[current.routes.length - 1];\n\n    if (current.routes.length === 1) {\n      params.initial = true;\n      params.screen = route.name;\n      params.state = undefined; // Explicitly set to override existing value when merging params\n    } else if (\n      current.routes.length === 2 &&\n      current.routes[0].key === undefined &&\n      current.routes[0].name === config?.initialRouteName\n    ) {\n      params.initial = false;\n      params.screen = route.name;\n      params.state = undefined;\n    } else {\n      params.initial = undefined;\n      params.screen = undefined;\n      params.params = undefined;\n      params.state = current;\n      break;\n    }\n\n    if (route.state) {\n      params.params = { ...route.params };\n      params = params.params;\n    } else {\n      params.params = route.params;\n    }\n\n    current = route.state;\n    config = config?.screens?.[route.name];\n\n    if (!payload) {\n      payload = {\n        name: route.name,\n        params,\n      };\n    }\n  }\n\n  if (!payload) {\n    return;\n  }\n\n  // Try to construct payload for a `NAVIGATE` action from the state\n  // This lets us preserve the navigation state and not lose it\n  return {\n    type: 'NAVIGATE',\n    payload,\n  };\n}\n\nconst createNormalizedConfigItem = (config: PathConfig | string) =>\n  typeof config === 'object' && config != null\n    ? {\n        initialRouteName: config.initialRouteName,\n        screens:\n          config.screens != null\n            ? createNormalizedConfigs(config.screens)\n            : undefined,\n      }\n    : {};\n\nconst createNormalizedConfigs = (options: PathConfigMap) =>\n  Object.entries(options).reduce<Record<string, ConfigItem>>((acc, [k, v]) => {\n    acc[k] = createNormalizedConfigItem(v);\n    return acc;\n  }, {});\n"]},"metadata":{},"sourceType":"module"}